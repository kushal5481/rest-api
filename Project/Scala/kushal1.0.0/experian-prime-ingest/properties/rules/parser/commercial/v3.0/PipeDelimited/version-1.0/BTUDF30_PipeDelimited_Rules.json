[
  {
    "rule_id": "R100001",
    "rule_name": "HEADER_FIRST_RECORD",
    "rule_level": "FILE",
    "rule_engine_type": "SQL",
    "rule_type": "MANDATORY",
    "rule_category": "STRUCTURAL",
    "rule_status": "ACTIVE",
    "error_type": "FATAL",
    "severity": "CRITICAL",
    "rule_stage": "PARSER",
    "rule_priority": 1,
    "rule_action": "REJECT",
    "error_code": "HEADER_NOT_FIRST",
    "error_message": "Header must be first record when mandatory.",
    "segment": [],
    "field_tag": [],
    "SQL_expression": "NOT (SELECT segment_is_mandatory FROM header_constraints) OR ((SELECT lower(Type_of_Line) FROM df_raw ORDER BY CAST(split(RecordID,'-')[0] AS INT) ASC LIMIT 1) = 'header')",
    "DSL_condition": null,
    "expected_value_source": "NONE",
    "expected_values": [],
    "spec_date": "2025-DEC-10",
    "metric_code": "M100001"
  },
  {
    "rule_id": "R100002",
    "rule_name": "HEADER_SINGLE_OCCURRENCE",
    "rule_level": "FILE",
    "rule_engine_type": "SQL",
    "rule_type": "MANDATORY",
    "rule_category": "STRUCTURAL",
    "rule_status": "ACTIVE",
    "error_type": "FATAL",
    "severity": "CRITICAL",
    "rule_stage": "PARSER",
    "rule_priority": 2,
    "rule_action": "REJECT",
    "error_code": "HEADER_COUNT_INVALID",
    "error_message": "Header must occur exactly once when mandatory.",
    "segment": [],
    "field_tag": [],
    "SQL_expression": "CASE WHEN (SELECT segment_is_mandatory FROM header_constraints) THEN (SELECT COUNT(*) FROM df_raw WHERE lower(Type_of_Line)='header') = 1 ELSE (SELECT COUNT(*) FROM df_raw WHERE lower(Type_of_Line)='header') IN (0,1) END",
    "DSL_condition": null,
    "expected_value_source": "NONE",
    "expected_values": [],
    "spec_date": "2025-DEC-10",
    "metric_code": "M100002"
  },
  {
    "rule_id": "R200001",
    "rule_name": "FOOTER_LAST_RECORD",
    "rule_level": "FILE",
    "rule_engine_type": "SQL",
    "rule_type": "MANDATORY",
    "rule_category": "STRUCTURAL",
    "rule_status": "ACTIVE",
    "error_type": "FATAL",
    "severity": "CRITICAL",
    "rule_stage": "PARSER",
    "rule_priority": 3,
    "rule_action": "REJECT",
    "error_code": "FOOTER_NOT_LAST",
    "error_message": "Footer must be last record when mandatory.",
    "segment": [],
    "field_tag": [],
    "SQL_expression": "NOT (SELECT segment_is_mandatory FROM footer_constraints) OR ((SELECT lower(Type_of_Line) FROM df_raw ORDER BY CAST(split(RecordID,'-')[0] AS INT) DESC LIMIT 1) = 'footer')",
    "DSL_condition": null,
    "expected_value_source": "NONE",
    "expected_values": [],
    "spec_date": "2025-DEC-16",
    "metric_code": "M200001"
  },
  {
    "rule_id": "R200002",
    "rule_name": "FOOTER_SINGLE_OCCURRENCE",
    "rule_level": "FILE",
    "rule_engine_type": "SQL",
    "rule_type": "MANDATORY",
    "rule_category": "STRUCTURAL",
    "rule_status": "ACTIVE",
    "error_type": "FATAL",
    "severity": "CRITICAL",
    "rule_stage": "PARSER",
    "rule_priority": 4,
    "rule_action": "REJECT",
    "error_code": "FOOTER_COUNT_INVALID",
    "error_message": "Footer must occur exactly once when mandatory.",
    "segment": [],
    "field_tag": [],
    "SQL_expression": "CASE WHEN (SELECT segment_is_mandatory FROM footer_constraints) THEN (SELECT COUNT(*) FROM df_raw WHERE lower(Type_of_Line)='footer') = 1 ELSE (SELECT COUNT(*) FROM df_raw WHERE lower(Type_of_Line)='footer') IN (0,1) END",
    "DSL_condition": null,
    "expected_value_source": "NONE",
    "expected_values": [],
    "spec_date": "2025-DEC-16",
    "metric_code": "M200002"
  },
  {
    "rule_id": "R100003",
    "rule_name": "HEADER_MANDATORY_FIELDS_PRESENT_IN_ORDER",
    "rule_level": "FILE",
    "rule_engine_type": "SQL",
    "rule_type": "MANDATORY",
    "rule_category": "STRUCTURAL",
    "rule_status": "ACTIVE",
    "error_type": "FATAL",
    "severity": "CRITICAL",
    "rule_stage": "PARSER",
    "rule_priority": 5,
    "rule_action": "REJECT",
    "error_code": "HD_FIELDS_MANDATORY_MISSING",
    "error_message": "All mandatory header fields must be present and non-empty in sequence.",
    "segment": [],
    "field_tag": [],
    "SQL_expression": "CASE WHEN (SELECT COUNT(*) from df_raw where lower(Type_of_Line)='header') = 0 THEN TRUE ELSE (SELECT COUNT(*) FROM df_raw r CROSS JOIN header_fields f CROSS JOIN header_fields_delimiter d WHERE lower(r.Type_of_Line)='header' AND f.field_is_mandatory='true' AND LENGTH(TRIM(split(r.RawRecord, d.delimiter_regex)[CAST(f.index_in_pipe AS INT)])) = 0) = 0 END",
    "DSL_condition": null,
    "expected_value_source": "NONE",
    "expected_values": [],
    "spec_date": "2025-DEC-16",
    "metric_code": "M100003"
  },
  {
    "rule_id": "R100004",
    "rule_name": "HEADER_EXPECTED_VALUES_CHECK",
    "rule_level": "FILE",
    "rule_engine_type": "SQL",
    "rule_type": "MANDATORY",
    "rule_category": "STRUCTURAL",
    "rule_status": "ACTIVE",
    "error_type": "FATAL",
    "severity": "CRITICAL",
    "rule_stage": "PARSER",
    "rule_priority": 6,
    "rule_action": "REJECT",
    "error_code": "HD_FIELDS_EXPECTED_MISMATCH",
    "error_message": "Header field value must match one of the expected values.",
    "segment": [],
    "field_tag": [],
    "SQL_expression": "CASE WHEN (SELECT COUNT(*) FROM df_raw WHERE lower(Type_of_Line)='header') = 0 THEN TRUE ELSE (SELECT MAX(CASE WHEN lower(r.Type_of_Line)='header' THEN CASE WHEN COALESCE(f.field_expected_values,'') = '' THEN 1 WHEN array_contains(transform(split(f.field_expected_values, ','), x -> lower(trim(x))), lower(trim(split(r.RawRecord, d.delimiter_regex)[CAST(f.index_in_pipe AS INT)]))) THEN 1 ELSE 0 END END) FROM df_raw r CROSS JOIN header_fields f CROSS JOIN header_fields_delimiter d WHERE f.field_index='0') = 1 END",
    "DSL_condition": null,
    "expected_value_source": "NONE",
    "expected_values": [],
    "spec_date": "2025-DEC-16",
    "metric_code": "M100004"
  },
  {
    "rule_id": "R100005",
    "rule_name": "HEADER_FIELDS_LENGTH_MATCH",
    "rule_level": "FILE",
    "rule_engine_type": "SQL",
    "rule_type": "MANDATORY",
    "rule_category": "STRUCTURAL",
    "rule_status": "ACTIVE",
    "error_type": "FATAL",
    "severity": "CRITICAL",
    "rule_stage": "PARSER",
    "rule_priority": 7,
    "rule_action": "REJECT",
    "error_code": "HD_FIELDS_LENGTH_MISMATCH",
    "error_message": "Each mandatory header field value length must not exceed expected field maximum length.",
    "segment": [],
    "field_tag": [],
    "SQL_expression": "CASE WHEN (SELECT COUNT(*) FROM df_raw WHERE lower(Type_of_Line)='header')=0 THEN TRUE ELSE (SELECT COUNT(*) FROM df_raw r CROSS JOIN header_fields f CROSS JOIN header_fields_delimiter d WHERE lower(r.Type_of_Line)='header' AND f.field_is_mandatory='true' AND LENGTH(COALESCE(split(r.RawRecord, d.delimiter_regex)[CAST(f.index_in_pipe AS INT)], '')) > CAST(f.field_max_length AS INT)) = 0 END",
    "DSL_condition": null,
    "expected_value_source": "NONE",
    "expected_values": [],
    "spec_date": "2025-DEC-16",
    "metric_code": "M100005"
  },
  {
    "rule_id": "R100006",
    "rule_name": "HEADER_DELIMITER_COUNT_MATCH",
    "rule_level": "FILE",
    "rule_engine_type": "SQL",
    "rule_type": "MANDATORY",
    "rule_category": "STRUCTURAL",
    "rule_status": "ACTIVE",
    "error_type": "FATAL",
    "severity": "CRITICAL",
    "rule_stage": "PARSER",
    "rule_priority": 8,
    "rule_action": "REJECT",
    "error_code": "HD_DELIMITER_COUNT_INVALID",
    "error_message": "Header delimiter count must match expected count for pipe delimited format.",
    "segment": [],
    "field_tag": [],
    "SQL_expression": "CASE WHEN (SELECT COUNT(*) FROM df_raw WHERE lower(Type_of_Line)='header') = 0 AND (SELECT segment_is_mandatory FROM header_constraints) THEN FALSE ELSE (SELECT COUNT(*) FROM df_raw r CROSS JOIN header_constraints hc CROSS JOIN header_fields_delimiter d WHERE lower(r.Type_of_Line)='header' AND (LENGTH(r.RawRecord) - LENGTH(REPLACE(r.RawRecord, d.delimiter_literal, ''))) / LENGTH(d.delimiter_literal) <> CAST(hc.segment_delimiter_count AS INT)) = 0 END",
    "DSL_condition": null,
    "expected_value_source": "NONE",
    "expected_values": [],
    "spec_date": "2025-DEC-16",
    "metric_code": "M100006"
  },
  {
    "rule_id": "R200003",
    "rule_name": "FOOTER_MANDATORY_FIELDS_PRESENT_IN_ORDER",
    "rule_level": "FILE",
    "rule_engine_type": "SQL",
    "rule_type": "MANDATORY",
    "rule_category": "STRUCTURAL",
    "rule_status": "ACTIVE",
    "error_type": "FATAL",
    "severity": "CRITICAL",
    "rule_stage": "PARSER",
    "rule_priority": 9,
    "rule_action": "REJECT",
    "error_code": "TS_FIELDS_MANDATORY_MISSING",
    "error_message": "All mandatory footer fields must be present and non-empty in sequence.",
    "segment": [],
    "field_tag": [],
    "SQL_expression": "CASE WHEN (SELECT COUNT(*) FROM df_raw WHERE lower(Type_of_Line)='footer') = 0 THEN TRUE ELSE (SELECT COUNT(*) FROM df_raw r CROSS JOIN footer_fields f CROSS JOIN footer_fields_delimiter d WHERE lower(r.Type_of_Line)='footer' AND f.field_is_mandatory='true' AND LENGTH(TRIM(split(r.RawRecord, d.delimiter_regex)[CAST(f.index_in_pipe AS INT)])) = 0) = 0 END",
    "DSL_condition": null,
    "expected_value_source": "NONE",
    "expected_values": [],
    "spec_date": "2025-DEC-16",
    "metric_code": "M200003"
  },
  {
    "rule_id": "R200004",
    "rule_name": "FOOTER_EXPECTED_VALUES_CHECK",
    "rule_level": "FILE",
    "rule_engine_type": "SQL",
    "rule_type": "MANDATORY",
    "rule_category": "STRUCTURAL",
    "rule_status": "ACTIVE",
    "error_type": "FATAL",
    "severity": "CRITICAL",
    "rule_stage": "PARSER",
    "rule_priority": 10,
    "rule_action": "REJECT",
    "error_code": "TS_FIELDS_EXPECTED_MISMATCH",
    "error_message": "Footer field value must match one of the expected values.",
    "segment": [],
    "field_tag": [],
    "SQL_expression": "CASE WHEN (SELECT COUNT(*) FROM df_raw WHERE lower(Type_of_Line)='footer') = 0 THEN TRUE ELSE (SELECT MAX(CASE WHEN lower(r.Type_of_Line)='footer' THEN CASE WHEN COALESCE(f.field_expected_values,'') = '' THEN 1 WHEN array_contains(transform(split(f.field_expected_values, ','), x -> lower(trim(x))), lower(trim(split(r.RawRecord, d.delimiter_regex)[CAST(f.index_in_pipe AS INT)]))) THEN 1 ELSE 0 END END) FROM df_raw r CROSS JOIN footer_fields f CROSS JOIN footer_fields_delimiter d WHERE f.field_index='0') = 1 END",
    "DSL_condition": null,
    "expected_value_source": "NONE",
    "expected_values": [],
    "spec_date": "2025-DEC-16",
    "metric_code": "M200004"
  },
  {
    "rule_id": "R200005",
    "rule_name": "FOOTER_FIELDS_LENGTH_MATCH",
    "rule_level": "FILE",
    "rule_engine_type": "SQL",
    "rule_type": "MANDATORY",
    "rule_category": "STRUCTURAL",
    "rule_status": "ACTIVE",
    "error_type": "FATAL",
    "severity": "CRITICAL",
    "rule_stage": "PARSER",
    "rule_priority": 11,
    "rule_action": "REJECT",
    "error_code": "TS_FIELDS_LENGTH_MISMATCH",
    "error_message": "Each mandatory footer field value length must not exceed expected field maximum length.",
    "segment": [],
    "field_tag": [],
    "SQL_expression": "CASE WHEN (SELECT COUNT(*) FROM df_raw WHERE lower(Type_of_Line)='footer')=0 THEN TRUE ELSE (SELECT COUNT(*) FROM df_raw r CROSS JOIN footer_fields f CROSS JOIN footer_fields_delimiter d WHERE lower(r.Type_of_Line)='footer' AND f.field_is_mandatory='true' AND LENGTH(COALESCE(split(r.RawRecord, d.delimiter_regex)[CAST(f.index_in_pipe AS INT)], '')) > CAST(f.field_max_length AS INT)) = 0 END",
    "DSL_condition": null,
    "expected_value_source": "NONE",
    "expected_values": [],
    "spec_date": "2025-DEC-16",
    "metric_code": "M200005"
  },
  {
    "rule_id": "R200006",
    "rule_name": "FOOTER_DELIMITER_COUNT_MATCH",
    "rule_level": "FILE",
    "rule_engine_type": "SQL",
    "rule_type": "MANDATORY",
    "rule_category": "STRUCTURAL",
    "rule_status": "ACTIVE",
    "error_type": "FATAL",
    "severity": "CRITICAL",
    "rule_stage": "PARSER",
    "rule_priority": 12,
    "rule_action": "REJECT",
    "error_code": "TS_DELIMITER_COUNT_INVALID",
    "error_message": "Footer delimiter count must match expected count for pipe delimited format.",
    "segment": [],
    "field_tag": [],
    "SQL_expression": "CASE WHEN (SELECT COUNT(*) FROM df_raw WHERE lower(Type_of_Line)='footer') = 0 AND (SELECT segment_is_mandatory FROM footer_constraints) THEN FALSE ELSE (SELECT COUNT(*) FROM df_raw r CROSS JOIN footer_constraints fc CROSS JOIN footer_fields_delimiter d WHERE lower(r.Type_of_Line)='footer' AND (LENGTH(r.RawRecord) - LENGTH(REPLACE(r.RawRecord, d.delimiter_literal, ''))) / LENGTH(d.delimiter_literal) <> CAST(fc.segment_delimiter_count AS INT)) = 0 END",
    "DSL_condition": null,
    "expected_value_source": "NONE",
    "expected_values": [],
    "spec_date": "2025-DEC-16",
    "metric_code": "M200006"
  },
  {
    "rule_id": "R300001",
    "rule_name": "SEGMENT_ORDER_MISMATCH",
    "rule_level": "RECORD",
    "rule_engine_type": "SQL",
    "rule_type": "MANDATORY",
    "rule_category": "STRUCTURAL",
    "rule_status": "ACTIVE",
    "error_type": "FATAL",
    "severity": "CRITICAL",
    "rule_stage": "PARSER",
    "rule_priority": 1,
    "rule_action": "REJECT",
    "error_code": "INVALID_SEGMENT_ORDER",
    "error_message": "Order of mandatory segment must match expected order.",
    "segment": [],
    "field_tag": [],
    "DSL_condition": null,
    "SQL_expression": "SELECT (SELECT pass FROM (SELECT (COUNT(DISTINCT tag) = 3) AND ((SELECT COUNT(*) FROM record_segments WHERE tag = 'BS') = 1) AS pass FROM record_segments WHERE tag IN ('BS', 'AS', 'CR'))) AND (SELECT pass FROM (SELECT tag = 'BS' AS pass FROM record_segments WHERE pos = 1)) AND (SELECT error_count FROM (SELECT COUNT(*) AS error_count FROM (SELECT LAG(tag, 1) OVER (ORDER BY pos) AS prev_tag, tag AS curr_tag, pos FROM record_segments) AS transitions WHERE pos > 1 AND CASE prev_tag WHEN 'BS' THEN curr_tag NOT IN ('AS') WHEN 'AS' THEN curr_tag NOT IN ('AS', 'RS') WHEN 'RS' THEN curr_tag NOT IN ('RS', 'CR') WHEN 'CR' THEN curr_tag NOT IN ('CR', 'GS', 'SS', 'CD', 'BS', 'TS') WHEN 'GS' THEN curr_tag NOT IN ('GS', 'SS', 'CD', 'CR', 'BS', 'TS') WHEN 'SS' THEN curr_tag NOT IN ('SS', 'CD', 'CR', 'BS', 'TS') WHEN 'CD' THEN curr_tag NOT IN ('CD', 'CR', 'BS', 'TS') ELSE TRUE END)) = 0 AS ok",
    "expected_value_source": "NONE",
    "expected_values": [],
    "spec_date": "2025-DEC-16",
    "metric_code": "M300001"
  },
  {
    "rule_id": "R400001",
    "rule_name": "SEGMENT_DELIMITER_COUNT_MISMATCH",
    "rule_level": "SEGMENT",
    "rule_engine_type": "SQL",
    "rule_type": "MANDATORY",
    "rule_category": "STRUCTURAL",
    "rule_status": "ACTIVE",
    "error_type": "FATAL",
    "severity": "CRITICAL",
    "rule_stage": "PARSER",
    "rule_priority": 1,
    "rule_action": "REJECT",
    "error_code": "INVALID_DELIMITER_COUNT",
    "error_message": "Count of delimiter in mandatory segment must match expected count.",
    "segment": [],
    "field_tag": [],
    "DSL_condition": null,
    "SQL_expression": "segment_is_mandatory = FALSE OR actual_delimiter_count = expected_delimiter_count",
    "expected_value_source": "NONE",
    "expected_values": [],
    "spec_date": "2025-DEC-23",
    "metric_code": "M400001"
  },
  {
    "rule_id": "R500001",
    "rule_name": "FIELD_VALUE_LENGTH_MISMATCH",
    "rule_level": "FIELD",
    "rule_engine_type": "SQL",
    "rule_type": "MANDATORY",
    "rule_category": "STRUCTURAL",
    "rule_status": "ACTIVE",
    "error_type": "FATAL",
    "severity": "CRITICAL",
    "rule_stage": "PARSER",
    "rule_priority": 1,
    "rule_action": "REJECT",
    "error_code": "INVALID_LENGTH",
    "error_message": "Mandatory field value length must not exceed expected maximum length.",
    "segment": [],
    "field_tag": [],
    "DSL_condition": null,
    "SQL_expression": "is_mandatory = TRUE AND field_value IS NOT NULL AND TRIM(field_value) != '' AND LENGTH(field_value) <= max_field_length",
    "expected_value_source": "NONE",
    "expected_values": [],
    "spec_date": "2025-DEC-23",
    "metric_code": "M500001"
  }
]