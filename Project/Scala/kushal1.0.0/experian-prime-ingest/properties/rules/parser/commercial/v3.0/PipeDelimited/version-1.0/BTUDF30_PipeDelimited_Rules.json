[
  {
    "rule_id": "R100001",
    "rule_name": "HEADER_FIRST_RECORD",
    "rule_level": "FILE",
    "rule_engine_type": "SQL",
    "rule_type": "MANDATORY",
    "rule_category": "STRUCTURAL",
    "rule_status": "ACTIVE",
    "error_type": "FATAL",
    "severity": "CRITICAL",
    "rule_stage": "PARSER",
    "rule_priority": 1,
    "rule_action": "REJECT",
    "error_code": "HEADER_NOT_FIRST",
    "error_message": "Header must be first record when mandatory.",
    "segment": ["HD"],
    "field_tag": [],
    "SQL_expression": "SELECT MAX(CASE WHEN hc.segment_is_mandatory = TRUE THEN CASE WHEN rec.rid = m.min_rid AND rec.tol = 'header' THEN 1 ELSE 0 END ELSE 1 END) = 1 AS ok FROM (SELECT CAST(split(RecordID,'-')[0] AS INT) AS rid, lower(Type_of_Line) AS tol FROM df_raw) rec CROSS JOIN header_constraints hc CROSS JOIN (SELECT MIN(CAST(split(RecordID,'-')[0] AS INT)) AS min_rid FROM df_raw) m",
    "DSL_condition": null,
    "expected_value_source": "NONE",
    "expected_values": [],
    "spec_date": "2025-DEC-10",
    "metric_code": "M100001"
  },
  {
    "rule_id": "R100002",
    "rule_name": "HEADER_SINGLE_OCCURRENCE",
    "rule_level": "FILE",
    "rule_engine_type": "SQL",
    "rule_type": "MANDATORY",
    "rule_category": "STRUCTURAL",
    "rule_status": "ACTIVE",
    "error_type": "FATAL",
    "severity": "CRITICAL",
    "rule_stage": "PARSER",
    "rule_priority": 2,
    "rule_action": "REJECT",
    "error_code": "HEADER_COUNT_INVALID",
    "error_message": "Header must occur exactly once when mandatory.",
    "segment": ["HD"],
    "field_tag": [],
    "SQL_expression": "SELECT CASE WHEN MAX(CASE WHEN hc.segment_is_mandatory = TRUE THEN 1 ELSE 0 END) = 1 THEN SUM(CASE WHEN lower(r.Type_of_Line)='header' THEN 1 ELSE 0 END) = 1 ELSE SUM(CASE WHEN lower(r.Type_of_Line)='header' THEN 1 ELSE 0 END) IN (0,1) END AS ok FROM df_raw r CROSS JOIN header_constraints hc",
    "DSL_condition": null,
    "expected_value_source": "NONE",
    "expected_values": [],
    "spec_date": "2025-DEC-10",
    "metric_code": "M100002"
  },
  {
    "rule_id": "R200001",
    "rule_name": "FOOTER_LAST_RECORD",
    "rule_level": "FILE",
    "rule_engine_type": "SQL",
    "rule_type": "MANDATORY",
    "rule_category": "STRUCTURAL",
    "rule_status": "ACTIVE",
    "error_type": "FATAL",
    "severity": "CRITICAL",
    "rule_stage": "PARSER",
    "rule_priority": 3,
    "rule_action": "REJECT",
    "error_code": "FOOTER_NOT_LAST",
    "error_message": "Footer must be last record when mandatory.",
    "segment": ["TS"],
    "field_tag": [],
    "SQL_expression": "SELECT MAX(CASE WHEN fc.segment_is_mandatory = TRUE THEN CASE WHEN rec.rid = m.max_rid AND rec.tol = 'footer' THEN 1 ELSE 0 END ELSE 1 END) = 1 AS ok FROM (SELECT CAST(split(RecordID,'-')[0] AS INT) AS rid, lower(Type_of_Line) AS tol FROM df_raw) rec CROSS JOIN footer_constraints fc CROSS JOIN (SELECT MAX(CAST(split(RecordID,'-')[0] AS INT)) AS max_rid FROM df_raw) m",
    "DSL_condition": null,
    "expected_value_source": "NONE",
    "expected_values": [],
    "spec_date": "2025-DEC-16",
    "metric_code": "M200001"
  },
  {
    "rule_id": "R200002",
    "rule_name": "FOOTER_SINGLE_OCCURRENCE",
    "rule_level": "FILE",
    "rule_engine_type": "SQL",
    "rule_type": "MANDATORY",
    "rule_category": "STRUCTURAL",
    "rule_status": "ACTIVE",
    "error_type": "FATAL",
    "severity": "CRITICAL",
    "rule_stage": "PARSER",
    "rule_priority": 4,
    "rule_action": "REJECT",
    "error_code": "FOOTER_COUNT_INVALID",
    "error_message": "Footer must occur exactly once when mandatory.",
    "segment": ["TS"],
    "field_tag": [],
    "SQL_expression": "SELECT CASE WHEN MAX(CASE WHEN fc.segment_is_mandatory = TRUE THEN 1 ELSE 0 END) = 1 THEN SUM(CASE WHEN lower(r.Type_of_Line)='footer' THEN 1 ELSE 0 END) = 1 ELSE SUM(CASE WHEN lower(r.Type_of_Line)='footer' THEN 1 ELSE 0 END) IN (0,1) END AS ok FROM df_raw r CROSS JOIN footer_constraints fc",
    "DSL_condition": null,
    "expected_value_source": "NONE",
    "expected_values": [],
    "spec_date": "2025-DEC-16",
    "metric_code": "M200002"
  },
  {
    "rule_id": "R100003",
    "rule_name": "HEADER_MANDATORY_FIELDS_PRESENT_IN_ORDER",
    "rule_level": "FILE",
    "rule_engine_type": "SQL",
    "rule_type": "MANDATORY",
    "rule_category": "STRUCTURAL",
    "rule_status": "ACTIVE",
    "error_type": "FATAL",
    "severity": "CRITICAL",
    "rule_stage": "PARSER",
    "rule_priority": 5,
    "rule_action": "REJECT",
    "error_code": "HD_FIELDS_MANDATORY_MISSING",
    "error_message": "All mandatory header fields must be present and non-empty in sequence.",
    "segment": ["HD"],
    "field_tag": [],
    "SQL_expression": "SELECT CASE WHEN SUM(CASE WHEN lower(r.Type_of_Line)='header' THEN 1 ELSE 0 END)=0 THEN TRUE ELSE SUM(CASE WHEN lower(r.Type_of_Line)='header' AND f.field_is_mandatory='true' AND LENGTH(TRIM(split(r.RawRecord, d.delimiter_regex)[CAST(f.index_in_pipe AS INT)])) = 0 THEN 1 ELSE 0 END) = 0 END AS ok FROM df_raw r CROSS JOIN header_fields f CROSS JOIN header_fields_delimiter d",
    "DSL_condition": null,
    "expected_value_source": "NONE",
    "expected_values": [],
    "spec_date": "2025-DEC-16",
    "metric_code": "M100003"
  },
  {
    "rule_id": "R100004",
    "rule_name": "HEADER_EXPECTED_VALUES_CHECK",
    "rule_level": "FILE",
    "rule_engine_type": "SQL",
    "rule_type": "MANDATORY",
    "rule_category": "STRUCTURAL",
    "rule_status": "ACTIVE",
    "error_type": "FATAL",
    "severity": "CRITICAL",
    "rule_stage": "PARSER",
    "rule_priority": 6,
    "rule_action": "REJECT",
    "error_code": "HD_FIELDS_EXPECTED_MISMATCH",
    "error_message": "Header field value must match one of the expected values.",
    "segment": ["HD"],
    "field_tag": [],
    "SQL_expression": "SELECT CASE WHEN SUM(CASE WHEN lower(r.Type_of_Line)='header' THEN 1 ELSE 0 END)=0 THEN TRUE ELSE MAX(CASE WHEN lower(r.Type_of_Line)='header' THEN CASE WHEN COALESCE(f.field_expected_values,'') = '' THEN 1 ELSE CASE WHEN array_contains(transform(split(f.field_expected_values, ','), x -> lower(trim(x))), lower(trim(split(r.RawRecord, d.delimiter_regex)[CAST(f.index_in_pipe AS INT)]))) THEN 1 ELSE 0 END END ELSE 0 END) = 1 END AS ok FROM df_raw r CROSS JOIN header_fields f CROSS JOIN header_fields_delimiter d WHERE f.field_index='0'",
    "DSL_condition": null,
    "expected_value_source": "NONE",
    "expected_values": [],
    "spec_date": "2025-DEC-16",
    "metric_code": "M100004"
  },
  {
    "rule_id": "R100005",
    "rule_name": "HEADER_FIELDS_LENGTH_MATCH",
    "rule_level": "FILE",
    "rule_engine_type": "SQL",
    "rule_type": "MANDATORY",
    "rule_category": "STRUCTURAL",
    "rule_status": "ACTIVE",
    "error_type": "FATAL",
    "severity": "CRITICAL",
    "rule_stage": "PARSER",
    "rule_priority": 7,
    "rule_action": "REJECT",
    "error_code": "HD_FIELDS_LENGTH_MISMATCH",
    "error_message": "Each mandatory header field value length must not exceed expected field maximum length.",
    "segment": ["HD"],
    "field_tag": [],
    "SQL_expression": "SELECT CASE WHEN SUM(CASE WHEN lower(r.Type_of_Line)='header' THEN 1 ELSE 0 END)=0 THEN TRUE ELSE SUM(CASE WHEN lower(r.Type_of_Line)='header' AND f.field_is_mandatory='true' AND LENGTH(COALESCE(split(r.RawRecord, d.delimiter_regex)[CAST(f.index_in_pipe AS INT)], '')) > CAST(f.field_max_length AS INT) THEN 1 ELSE 0 END) = 0 END AS ok FROM df_raw r CROSS JOIN header_fields f CROSS JOIN header_fields_delimiter d",
    "DSL_condition": null,
    "expected_value_source": "NONE",
    "expected_values": [],
    "spec_date": "2025-DEC-16",
    "metric_code": "M100005"
  },
  {
    "rule_id": "R100006",
    "rule_name": "HEADER_DELIMITER_COUNT_MATCH",
    "rule_level": "FILE",
    "rule_engine_type": "SQL",
    "rule_type": "MANDATORY",
    "rule_category": "STRUCTURAL",
    "rule_status": "ACTIVE",
    "error_type": "FATAL",
    "severity": "CRITICAL",
    "rule_stage": "PARSER",
    "rule_priority": 8,
    "rule_action": "REJECT",
    "error_code": "HD_DELIMITER_COUNT_INVALID",
    "error_message": "Header delimiter count must match expected count for pipe delimited format.",
    "segment": ["HD"],
    "field_tag": [],
    "SQL_expression": "SELECT CASE WHEN MAX(CASE WHEN lower(hc.segment_is_mandatory)='true' THEN 1 ELSE 0 END) = 1 AND SUM(CASE WHEN lower(r.Type_of_Line)='header' THEN 1 ELSE 0 END) = 0 THEN FALSE ELSE SUM(CASE WHEN lower(r.Type_of_Line)='header' AND (LENGTH(r.RawRecord) - LENGTH(REPLACE(r.RawRecord, d.delimiter_literal, ''))) / LENGTH(d.delimiter_literal) <> CAST(hc.segment_delimiter_count AS INT) THEN 1 ELSE 0 END) = 0 END AS ok FROM df_raw r CROSS JOIN header_constraints hc CROSS JOIN header_fields_delimiter d",
    "DSL_condition": null,
    "expected_value_source": "NONE",
    "expected_values": [],
    "spec_date": "2025-DEC-16",
    "metric_code": "M100006"
  },
  {
    "rule_id": "R200003",
    "rule_name": "FOOTER_MANDATORY_FIELDS_PRESENT_IN_ORDER",
    "rule_level": "FILE",
    "rule_engine_type": "SQL",
    "rule_type": "MANDATORY",
    "rule_category": "STRUCTURAL",
    "rule_status": "ACTIVE",
    "error_type": "FATAL",
    "severity": "CRITICAL",
    "rule_stage": "PARSER",
    "rule_priority": 9,
    "rule_action": "REJECT",
    "error_code": "TS_FIELDS_MANDATORY_MISSING",
    "error_message": "All mandatory footer fields must be present and non-empty in sequence.",
    "segment": ["TS"],
    "field_tag": [],
    "SQL_expression": "SELECT CASE WHEN SUM(CASE WHEN lower(r.Type_of_Line)='footer' THEN 1 ELSE 0 END)=0 THEN TRUE ELSE SUM(CASE WHEN lower(r.Type_of_Line)='footer' AND f.field_is_mandatory='true' AND LENGTH(TRIM(split(r.RawRecord, d.delimiter_regex)[CAST(f.index_in_pipe AS INT)])) = 0 THEN 1 ELSE 0 END) = 0 END AS ok FROM df_raw r CROSS JOIN footer_fields f CROSS JOIN footer_fields_delimiter d",
    "DSL_condition": null,
    "expected_value_source": "NONE",
    "expected_values": [],
    "spec_date": "2025-DEC-16",
    "metric_code": "M200003"
  },
  {
    "rule_id": "R200004",
    "rule_name": "FOOTER_EXPECTED_VALUES_CHECK",
    "rule_level": "FILE",
    "rule_engine_type": "SQL",
    "rule_type": "MANDATORY",
    "rule_category": "STRUCTURAL",
    "rule_status": "ACTIVE",
    "error_type": "FATAL",
    "severity": "CRITICAL",
    "rule_stage": "PARSER",
    "rule_priority": 10,
    "rule_action": "REJECT",
    "error_code": "TS_FIELDS_EXPECTED_MISMATCH",
    "error_message": "Footer field value must match one of the expected values.",
    "segment": ["TS"],
    "field_tag": [],
    "SQL_expression": "SELECT CASE WHEN SUM(CASE WHEN lower(r.Type_of_Line)='footer' THEN 1 ELSE 0 END)=0 THEN TRUE ELSE MAX(CASE WHEN lower(r.Type_of_Line)='footer' THEN CASE WHEN COALESCE(f.field_expected_values,'') = '' THEN 1 ELSE CASE WHEN array_contains(transform(split(f.field_expected_values, ','), x -> lower(trim(x))), lower(trim(split(r.RawRecord, d.delimiter_regex)[CAST(f.index_in_pipe AS INT)]))) THEN 1 ELSE 0 END END ELSE 0 END) = 1 END AS ok FROM df_raw r CROSS JOIN footer_fields f CROSS JOIN footer_fields_delimiter d WHERE f.field_index='0'",
    "DSL_condition": null,
    "expected_value_source": "NONE",
    "expected_values": [],
    "spec_date": "2025-DEC-16",
    "metric_code": "M200004"
  },
  {
    "rule_id": "R200005",
    "rule_name": "FOOTER_FIELDS_LENGTH_MATCH",
    "rule_level": "FILE",
    "rule_engine_type": "SQL",
    "rule_type": "MANDATORY",
    "rule_category": "STRUCTURAL",
    "rule_status": "ACTIVE",
    "error_type": "FATAL",
    "severity": "CRITICAL",
    "rule_stage": "PARSER",
    "rule_priority": 11,
    "rule_action": "REJECT",
    "error_code": "TS_FIELDS_LENGTH_MISMATCH",
    "error_message": "Each mandatory footer field value length must not exceed expected field maximum length.",
    "segment": ["TS"],
    "field_tag": [],
    "SQL_expression": "SELECT CASE WHEN SUM(CASE WHEN lower(r.Type_of_Line)='footer' THEN 1 ELSE 0 END)=0 THEN TRUE ELSE SUM(CASE WHEN lower(r.Type_of_Line)='footer' AND f.field_is_mandatory='true' AND LENGTH(COALESCE(split(r.RawRecord, d.delimiter_regex)[CAST(f.index_in_pipe AS INT)], '')) > CAST(f.field_max_length AS INT) THEN 1 ELSE 0 END) = 0 END AS ok FROM df_raw r CROSS JOIN footer_fields f CROSS JOIN footer_fields_delimiter d",
    "DSL_condition": null,
    "expected_value_source": "NONE",
    "expected_values": [],
    "spec_date": "2025-DEC-16",
    "metric_code": "M200005"
  },
  {
    "rule_id": "R200006",
    "rule_name": "FOOTER_DELIMITER_COUNT_MATCH",
    "rule_level": "FILE",
    "rule_engine_type": "SQL",
    "rule_type": "MANDATORY",
    "rule_category": "STRUCTURAL",
    "rule_status": "ACTIVE",
    "error_type": "FATAL",
    "severity": "CRITICAL",
    "rule_stage": "PARSER",
    "rule_priority": 12,
    "rule_action": "REJECT",
    "error_code": "TS_DELIMITER_COUNT_INVALID",
    "error_message": "Footer delimiter count must match expected count for pipe delimited format.",
    "segment": ["TS"],
    "field_tag": [],
    "SQL_expression": "SELECT CASE WHEN MAX(CASE WHEN lower(fc.segment_is_mandatory)='true' THEN 1 ELSE 0 END) = 1 AND SUM(CASE WHEN lower(r.Type_of_Line)='footer' THEN 1 ELSE 0 END) = 0 THEN FALSE ELSE SUM(CASE WHEN lower(r.Type_of_Line)='footer' AND (LENGTH(r.RawRecord) - LENGTH(REPLACE(r.RawRecord, d.delimiter_literal, ''))) / LENGTH(d.delimiter_literal) <> CAST(fc.segment_delimiter_count AS INT) THEN 1 ELSE 0 END) = 0 END AS ok FROM df_raw r CROSS JOIN footer_constraints fc CROSS JOIN footer_fields_delimiter d",
    "DSL_condition": null,
    "expected_value_source": "NONE",
    "expected_values": [],
    "spec_date": "2025-DEC-16",
    "metric_code": "M200006"
  },
  {
    "rule_id": "R300001",
    "rule_name": "SEGMENT_ORDER_MISMATCH",
    "rule_level": "RECORD",
    "rule_engine_type": "DSL",
    "rule_type": "MANDATORY",
    "rule_category": "STRUCTURAL",
    "rule_status": "ACTIVE",
    "error_type": "FATAL",
    "severity": "CRITICAL",
    "rule_stage": "PARSER",
    "rule_priority": 1,
    "rule_action": "REJECT",
    "error_code": "INVALID_SEGMENT_ORDER",
    "error_message": "Order of mandatory segment must match expected order.",
    "segment": [],
    "field_tag": [],
    "DSL_condition": "segment_sequence.containsAll(expected_segment_order) AND segment_sequence.inOrder(expected_segment_order)",
    "SQL_expression": "",
    "expected_value_source": "NONE",
    "expected_values": [],
    "spec_date": "2025-DEC-16",
    "metric_code": "M300001"
  },
  {
    "rule_id": "R400001",
    "rule_name": "SEGMENT_DELIMITER_COUNT_MISMATCH",
    "rule_level": "SEGMENT",
    "rule_engine_type": "DSL",
    "rule_type": "MANDATORY",
    "rule_category": "STRUCTURAL",
    "rule_status": "ACTIVE",
    "error_type": "FATAL",
    "severity": "CRITICAL",
    "rule_stage": "PARSER",
    "rule_priority": 1,
    "rule_action": "REJECT",
    "error_code": "INVALID_DELIMITER_COUNT",
    "error_message": "Count of delimiter in mandatory segment must match expected count.",
    "segment": [],
    "field_tag": [],
    "DSL_condition": "segment.segment_is_mandatory = false OR segment.actual_delimiter_count = segment.expected_delimiter_count",
    "SQL_expression": "",
    "expected_value_source": "NONE",
    "expected_values": [],
    "spec_date": "2025-DEC-23",
    "metric_code": "M400001"
  },
  {
    "rule_id": "R500001",
    "rule_name": "FIELD_VALUE_LENGTH_MISMATCH",
    "rule_level": "FIELD",
    "rule_engine_type": "DSL",
    "rule_type": "MANDATORY",
    "rule_category": "STRUCTURAL",
    "rule_status": "ACTIVE",
    "error_type": "FATAL",
    "severity": "CRITICAL",
    "rule_stage": "PARSER",
    "rule_priority": 1,
    "rule_action": "REJECT",
    "error_code": "INVALID_LENGTH",
    "error_message": "Mandatory field value length must not exceed expected maximum length.",
    "segment": [],
    "field_tag": [],
    "DSL_condition": "field.is_mandatory AND field.field_value IS NOT NULL AND TRIM(field.field_value) != '' AND LENGTH(field.field_value) <= field.max_field_length",
    "SQL_expression": "",
    "expected_value_source": "NONE",
    "expected_values": [],
    "spec_date": "2025-DEC-23",
    "metric_code": "M500001"
  }
]